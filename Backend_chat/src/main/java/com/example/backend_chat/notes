@Table(name = "messages", indexes = {
    @Index(name = "idx_chat_id", columnList = "chat_id"),
    @Index(name = "idx_sender_id", columnList = "sender_id"),
    @Index(name = "idx_receiver_id", columnList = "receiver_id")
})
}
MVP Minimum viable Product

âœ… User registration & login (JWT)

âœ… Real-time messaging (WebSocket)

âœ… Contact management (friend requests)

âœ… Chat UI (JavaFX in your case)

âœ… Message history (chat persistence)

âœ… Online status (optional)

âœ… Notifications (optional)

-------------------
phase (1)         done
Authentication Module :
Login / Register with JWT

User Entity, DTO, Controller, Service

Security Config (AuthenticationManager, filters (jwt))
____________________

Send friend request âœ… from search find user (handle search front and back )
Accept/Reject friend request âœ…
Accept/Reject friend request âœ…
WebSocket notification âœ…
_______________________________
message module

Define Message DTO (sender, receiver, content, timestamp)

WebSocket Configuration

STOMP Controller â€“ handle /send, subscribe to /user/topic/messages

Message persistence â€“ Save to DB (JPA)

Deliver to receiver â€“ WebSocket notification

Load message history â€“ REST endpoint


_----------------------------------
ðŸ“± 1. Login / Register Screen
Form inputs, HTTP request to backend

ðŸ“± 2. Contacts Screen
List of friends

Button to send friend request

Button to accept/reject request

ðŸ“± 3. Chat Screen
Chat area (messages)

Input box (send message via WebSocket)

Scroll + history loading (via REST)

___________________________________
âœ… Phase 4: Real-Time Communication
Key Tools:
WebSocket (Spring Boot backend)

STOMP (on both sides)

JavaFX client using STOMP client (like Tyrus or WebSocketClient)
Connect on login

Subscribe to /user/topic/messages

Receive new messages instantly

____________________________________
